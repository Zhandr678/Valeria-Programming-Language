
//                         Aladdin Free Public License
//                      (Version 9, September 18, 2000)
//
//    Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000 Aladdin Enterprises,
//            Menlo Park, California, U.S.A. All rights reserved.
//
//     NOTE: This License is not the same as any of the GNU Licenses
//     published by the Free Software Foundation. Its terms are
//     substantially different from those of the GNU Licenses. If you are
//     familiar with the GNU Licenses, please read this license with
//     extra care.
//
// Aladdin Enterprises hereby grants to anyone the permission to apply this
// License to their own work, as long as the entire License (including the
// above notices and this paragraph) is copied with no changes, additions, or
// deletions except for changing the first paragraph of Section 0 to include a
// suitable description of the work to which the license is being applied and
// of the person or entity that holds the copyright in the work, and, if the
// License is being applied to a work created in a country other than the
// United States, replacing the first paragraph of Section 6 with an
// appropriate reference to the laws of the appropriate country.

// This License is not an Open Source license: among other things, it places
// restrictions on distribution of the Program, specifically including sale of
// the Program. While Aladdin Enterprises respects and supports the philosophy
// of the Open Source Definition, and shares the desire of the GNU project to
// keep licensed software freely redistributable in both source and object
// form, we feel that Open Source licenses unfairly prevent developers of
// useful software from being compensated proportionately when others profit
// financially from their work. This License attempts to ensure that those who
// receive, redistribute, and contribute to the licensed Program according to
// the Open Source and Free Software philosophies have the right to do so,
// while retaining for the developer(s) of the Program the power to make those
// who use the Program to enhance the value of commercial products pay for the
// privilege of doing so.

// 0. Subject Matter

// This License applies to the TVM library.
// In the rest of this license, the TVM library will be 
// referred to as "The Program". The Program is a copyrighted
// work whose copyright is with Hans de Nivelle, living in Dresden, Germany. 
// In the rest of license, "Hans de Nivelle" will be referred to as "Licensor".
// A "work based on the Program" means either the Program or any derivative
// work of the Program, as defined in the United States Copyright Act of 1976,
// such as a translation or a modification.

// BY MODIFYING OR DISTRIBUTING THE PROGRAM (OR ANY WORK BASED ON THE PROGRAM),
// YOU INDICATE YOUR ACCEPTANCE OF THIS LICENSE TO DO SO, AND ALL ITS TERMS AND
// CONDITIONS FOR COPYING, DISTRIBUTING OR MODIFYING THE PROGRAM OR WORKS BASED
// ON IT. NOTHING OTHER THAN THIS LICENSE GRANTS YOU PERMISSION TO MODIFY OR
// DISTRIBUTE THE PROGRAM OR ITS DERIVATIVE WORKS. THESE ACTIONS ARE PROHIBITED
// BY LAW. IF YOU DO NOT ACCEPT THESE TERMS AND CONDITIONS, DO NOT MODIFY OR
// DISTRIBUTE THE PROGRAM.

// 1. Licenses.

// Licensor hereby grants you the following rights, provided that you comply
// with all of the restrictions set forth in this License and provided,
// further, that you distribute an unmodified copy of this License with the
// Program:

// (a)  You may copy and distribute literal (i.e., verbatim) copies of the
//      Program's source code as you receive it throughout the world, in any
//      medium.
// (b)  You may modify the Program, create works based on the Program and
//      distribute copies of such throughout the world, in any medium.

// 2. Restrictions.

// This license is subject to the following restrictions:

// (a)  Distribution of the Program or any work based on the Program by a
//      commercial organization to any third party is prohibited if any payment
//      is made in connection with such distribution, whether directly (as in
//      payment for a copy of the Program) or indirectly (as in payment for
//      some service related to the Program, or payment for some product or
//      service that includes a copy of the Program "without charge"; these are
//      only examples, and not an exhaustive enumeration of prohibited
//      activities). The following methods of distribution involving payment
//      shall not in and of themselves be a violation of this restriction:
//      (i)  Posting the Program on a public access information storage and
//           retrieval service for which a fee is received for retrieving
//           information (such as an on-line service), provided that the fee is
//           not content-dependent (i.e., the fee would be the same for
//           retrieving the same volume of information consisting of random
//           data) and that access to the service and to the Program is
//           available independent of any other product or service. An example
//           of a service that does not fall under this section is an on-line
//           service that is operated by a company and that is only available
//           to customers of that company. (This is not an exhaustive
//           enumeration.)
//      (ii) Distributing the Program on removable computer-readable media,
//           provided that the files containing the Program are reproduced
//           entirely and verbatim on such media, that all information on such
//           media be redistributable for non-commercial purposes without
//           charge, and that such media are distributed by themselves (except
//           for accompanying documentation) independent of any other product
//           or service. Examples of such media include CD-ROM, magnetic tape,
//           and optical storage media. (This is not intended to be an
//           exhaustive list.) An example of a distribution that does not fall
//           under this section is a CD-ROM included in a book or magazine.
//           (This is not an exhaustive enumeration.)
// (b)  Activities other than copying, distribution and modification of the
//      Program are not subject to this License and they are outside its scope.
//      Functional use (running) of the Program is not restricted, and any
//      output produced through the use of the Program is subject to this
//      license only if its contents constitute a work based on the Program
//      (independent of having been made by running the Program).
// (c)  You must meet all of the following conditions with respect to any work
//      that you distribute or publish that in whole or in part contains or is
//      derived from the Program or any part thereof ("the Work"):
//      (i)  If you have modified the Program, you must cause the Work to carry
//           prominent notices stating that you have modified the Program's
//           files and the date of any change. In each source file that you
//           have modified, you must include a prominent notice that you have
//           modified the file, including your name, your e-mail address (if
//           any), and the date and purpose of the change;
//      (ii) You must cause the Work to be licensed as a whole and at no charge
//           to all third parties under the terms of this License;
//      (iii)
//           If the Work normally reads commands interactively when run, you
//           must cause it, at each time the Work commences operation, to print
//           or display an announcement including an appropriate copyright
//           notice and a notice that there is no warranty (or else, saying
//           that you provide a warranty). Such notice must also state that
//           users may redistribute the Work only under the conditions of this
//           License and tell the user how to view the copy of this License
//           included with the Work. (Exceptions: if the Program is interactive
//           but normally prints or displays such an announcement only at the
//           request of a user, such as in an "About box", the Work is required
//           to print or display the notice only under the same circumstances;
//           if the Program itself is interactive but does not normally print
//           such an announcement, the Work is not required to print an
//           announcement.);
//      (iv) You must accompany the Work with the complete corresponding
//           machine-readable source code, delivered on a medium customarily
//           used for software interchange. The source code for a work means
//           the preferred form of the work for making modifications to it. For
//           an executable work, complete source code means all the source code
//           for all modules it contains, plus any associated interface
//           definition files, plus the scripts used to control compilation and
//           installation of the executable code. If you distribute with the
//           Work any component that is normally distributed (in either source
//           or binary form) with the major components (compiler, kernel, and
//           so on) of the operating system on which the executable runs, you
//           must also distribute the source code of that component if you have
//           it and are allowed to do so;
//      (v)  If you distribute any written or printed material at all with the
//           Work, such material must include either a written copy of this
//           License, or a prominent written indication that the Work is
//           covered by this License and written instructions for printing
//           and/or displaying the copy of the License on the distribution
//           medium;
//      (vi) You may not impose any further restrictions on the recipient's
//           exercise of the rights granted herein.

// If distribution of executable or object code is made by offering the
// equivalent ability to copy from a designated place, then offering equivalent
// ability to copy the source code from the same place counts as distribution
// of the source code, even though third parties are not compelled to copy the
// source code along with the object code.

// 3. Reservation of Rights.

// No rights are granted to the Program except as expressly set forth herein.
// You may not copy, modify, sublicense, or distribute the Program except as
// expressly provided under this License. Any attempt otherwise to copy,
// modify, sublicense or distribute the Program is void, and will automatically
// terminate your rights under this License. However, parties who have received
// copies, or rights, from you under this License will not have their licenses
// terminated so long as such parties remain in full compliance.

// 4. Other Restrictions.

// If the distribution and/or use of the Program is restricted in certain
// countries for any reason, Licensor may add an explicit geographical
// distribution limitation excluding those countries, so that distribution is
// permitted only in or among countries not thus excluded. In such case, this
// License incorporates the limitation as if written in the body of this
// License.

// 5. Limitations.

// THE PROGRAM IS PROVIDED TO YOU "AS IS," WITHOUT WARRANTY. THERE IS NO
// WARRANTY FOR THE PROGRAM, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. THE ENTIRE
// RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD
// THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
// REPAIR OR CORRECTION.

// IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
// LICENSOR, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM
// AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL,
// SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
// INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
// DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES
// OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF
// SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
// DAMAGES.

// 6. General.

// This License is governed by the copyright laws of the European Union, 
// excluding choice of law rules.

// If any part of this License is found to be in conflict with the law, that
// part shall be interpreted in its broadest meaning consistent with the law,
// and no other parts of the License shall be affected.

// For United States Government users, the Program is provided with RESTRICTED
// RIGHTS. If you are a unit or agency of the United States Government or are
// acquiring the Program for any such unit or agency, the following apply:

//     If the unit or agency is the Department of Defense ("DOD"), the
//     Program and its documentation are classified as "commercial
//     computer software" and "commercial computer software
//     documentation" respectively and, pursuant to DFAR Section
//     227.7202, the Government is acquiring the Program and its
//     documentation in accordance with the terms of this License. If the
//     unit or agency is other than DOD, the Program and its
//     documentation are classified as "commercial computer software" and
//     "commercial computer software documentation" respectively and,
//     pursuant to FAR Section 12.212, the Government is acquiring the
//     Program and its documentation in accordance with the terms of this
//     License.




#ifndef TVM_SCALAR_REPEATED_
#define TVM_SCALAR_REPEATED_  1 

#include <new>
#include <utility>
#include <cstdint>

#include "concepts.h"
#include "hexprint.h"

// Written by Hans de Nivelle and Dina Muktubayeva 
// October-November 2022.

namespace tvm
{
   // This class is used only for determinizing sizes and offsets.
   // No instances are created. 

   template< typename S, typename R > 
   struct sr_size
   {
      size_t nrrefs;   
      size_t ss;    
      size_t cc;  
      S scal;  
      R r0; 

      sr_size( ) = delete;
      ~sr_size( ) = delete; 
         // To be sure that nobody will get the idea of
         // creating one. 
   };


   // We cannot have traditional constructors, because we need
   // to do the allocation by yourselves.
   // We have a destructor, but this destructor is incomplete, because 
   // it doesn't destroy the repeated part. 

   template< typename S, typename R >
   struct scalar_repeated 
   {
      size_t nrrefs;   
      size_t ss;  
      size_t cc;  
      S scal;  

      using SR = sr_size< S, R > ;
      static constexpr size_t size0 = offsetof( SR, r0 );

      scalar_repeated( const S& scal, size_t ss, size_t cc )
        : nrrefs(0), ss(ss), cc(cc), scal( scal ) 
      { }

      scalar_repeated( S&& scal, size_t ss, size_t cc )
        : nrrefs(0), ss(ss), cc(cc), scal( std::move( scal ))
      { }

      R* begin( )
      {
         return & (( sr_size<S,R> * ) this ) -> r0;
      }

      const R* begin( ) const
      { 
         return & (( const sr_size<S,R> * ) this ) -> r0; 
      }

      R* end( )
      {
         return & (( sr_size<S,R> * ) this ) -> r0 + ss;
      }

      const R* end( ) const
      {
         return & (( const sr_size<S,R> * ) this ) -> r0 + ss;
      }

      size_t size( ) const { return ss; }
      size_t capacity( ) const { return cc; } 

      ~scalar_repeated( ) = default;
      scalar_repeated( const scalar_repeated& ) = delete;
      scalar_repeated& operator = ( const scalar_repeated& ) = delete; 

   };

   // Allocate, but don't initialize:

   template< typename S, typename R > 
   scalar_repeated<S,R> * allocate( size_t cap )
   {
      size_t a = scalar_repeated<S,R> :: size0 + cap * sizeof(R); 
      return ( scalar_repeated<S,R> * ) operator new(a);  
   }

   // These functions should be viewed as constructors:

   template< typename S, typename R > 
   scalar_repeated<S,R> * 
   constr_scalar_repeated( const S& scal, size_t cap )
   {
      auto* alloc = allocate<S,R> ( cap );
      new (alloc) scalar_repeated<S,R> ( scal, 0, cap );
      return alloc; 
   }

   template< typename S, typename R, const_iterator<R> I > 
   scalar_repeated<S,R> * 
   constr_scalar_repeated( const S& scal, I begin, I end )
   {
      size_t cap = end - begin; 
      auto* alloc = allocate<S,R> ( cap );

      new (alloc) scalar_repeated<S,R> ( scal, cap, cap );
     
      R* to = alloc -> begin( );
      for( I from = begin; from != end; ++ from ) 
         new ( to ++ ) R( *from );

      return alloc;
   }

   template< typename S, typename R >
   scalar_repeated<S,R> *
   constr_scalar_repeated( S&& scal, size_t cap )
   {
      auto* alloc = allocate<S,R> ( cap );
      new (alloc) scalar_repeated<S,R> ( std::move( scal ), 0, cap );
      return alloc;
   }

   template< typename S, typename R, move_iterator<R> I >
   scalar_repeated<S,R> *
   constr_scalar_repeated( S&& scal, I begin, I end )
   {
      size_t cap = end - begin;
      auto* alloc = allocate<S,R> ( cap );

      new (alloc) scalar_repeated<S,R> ( std::move( scal ), cap, cap );

      R* to = alloc -> begin( );
      for( I from = begin; from != end; ++ from )
         new ( to ++ ) R( *from );

      return alloc;
   }


   template< typename S, typename R >
   inline bool iswritable( const scalar_repeated<S,R> * sr ) 
   {
      return ( sr -> nrrefs ) == 1;
   }

   template< typename S, typename R > 
   scalar_repeated<S,R> * replacebywritable( scalar_repeated<S,R> * sr ) 
   {
      if( -- (  sr -> nrrefs ))
      {
         auto p = constr_scalar_repeated<S,R> ( sr -> scal, 
                                                sr -> begin( ), sr -> end( ));
         return p;
      }
      else
         return sr;
   }


   template< typename S, typename R >
   void printstate( const scalar_repeated<S,R> * sr, std::ostream& out ) 
   {
      auto s = (uintptr_t) sr; 
      hexprint( out, s, 2 ); 
      out << ", #" << sr -> nrrefs << ", ";
      out << ( sr -> ss ) << "/" << ( sr -> cc ); 
   }

   template< typename S, typename R >
   inline scalar_repeated<S,R> * 
   takeshare( scalar_repeated<S,R> * sr ) { ++ sr -> nrrefs; return sr; }     

   template< std::destructible S, std::destructible R >
   void dropshare( scalar_repeated<S,R> * sr ) 
   {
      if( -- sr -> nrrefs == 0 )
      {
         for( auto d = sr -> begin( ); d != sr -> end( ); ++ d ) 
            d -> ~R( );

         sr -> ~scalar_repeated<S,R> ( ); 

         void* del = (void*) sr; 
         operator delete( del ); 
      }
   }


   template< typename S, typename R, std::convertible_to<R> R1 > 
   scalar_repeated<S,R> * push_back( scalar_repeated<S,R> * sr, R1&& r )
   {

      if( sr -> nrrefs == 1 && sr -> ss < sr -> cc )
      {
         new ( sr->begin( ) + sr->ss ++ ) R( std::forward<R1> (r) );
         return sr;
      }

      // Otherwise, life is a bit harder, because we have to reallocate.
      // It is not certain that ( sr -> ss ) + 1 > ( sr -> cc ) because we may
      // be reallocating due to sharing. 

      // std::cout << "old: " << sr->ss << " " << sr->cc << "\n";

      size_t cc_new = sr -> cc;
      size_t ss_new = sr -> ss + 1;

      if( cc_new < ss_new ) 
         cc_new = ss_new << 1;

      // std::cout << "new: " << ss_new << " " << cc_new << "\n";

      auto* alloc = allocate<S,R> ( cc_new );

      if( sr -> nrrefs == 1 )
      {
         // If sr is not sharing, we move from it: 

         new (alloc) scalar_repeated<S,R> ( std::move( sr -> scal ), ss_new, cc_new );

         auto to = alloc -> begin( );
         for( auto from = sr -> begin( ); from != sr -> end( ); ++ from )
            new ( to ++ ) R( std::move( *from ));

         new( to ) R( std::forward<R1> (r) );
      }
      else
      {
         // If sr is sharing, we copy sr: 

         new (alloc) scalar_repeated<S,R>( sr -> scal, ss_new, cc_new );

         auto to = alloc -> begin( );
         for( auto from = sr -> begin( ); from != sr -> end( ); ++ from ) 
            new ( to ++ ) R( *from ); 

         new( to ) R( std::forward<R1> (r) );
      }

      dropshare( sr ); 
      return takeshare( alloc );  
   }
  
    
   template< typename S, typename R > 
   scalar_repeated<S,R> * pop_back( scalar_repeated<S,R> * sr )
   {
      sr = replacebywritable(sr);
      takeshare(sr);

      -- sr -> ss; 
      ( sr->begin( ) + sr->ss ) ->~R( );
      return sr;  
   }

   template< typename S, typename R >
   scalar_repeated<S,R> * clear( scalar_repeated<S,R> * sr )
   {
      if( sr -> nrrefs == 1 )
      {
         for( auto d = sr -> begin( ); d != sr -> end( ); ++ d )
            d -> ~R( );

         sr -> ss = 0;  
         return sr; 
      }
      else
      {
         -- ( sr -> nrrefs );  
                       // It cannot become zero, because we know it was > 1.  

         auto* alloc = allocate<S,R> ( sr -> cc ); 
         new (alloc) scalar_repeated<S,R>( sr -> scal, 0, sr -> cc ); 
         return takeshare( alloc ); 
      }
   }

}

#endif


